% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R
\name{leapGP}
\alias{leapGP}
\title{Localized Ensemble of Approximate Gaussian Processes}
\usage{
leapGP(
  X,
  y,
  M0 = ceiling(sqrt(length(y))),
  rho = NA,
  scale = FALSE,
  n = ceiling(sqrt(length(y))),
  start = NA,
  verbose = FALSE,
  justdoit = FALSE,
  ...
)
}
\arguments{
\item{X}{a matrix of training locations (1 row for each training instance)}

\item{y}{a vector of training responses (length(y) == nrow(X))}

\item{M0}{the number of prediction hubs desired. Defaults to ceiling(sqrt(length(Y))).}

\item{rho}{(optional). The parameter controlling time-accuracy tradeoff. Can alternatively be specified during prediction.}

\item{scale}{logical. Do we want the scale parameter to be returned for predictions? If TRUE,
the matrix K^{-1} will be stored for each hub.}

\item{n}{local neighborhood size (for laGP)}

\item{start}{number of starting points for neighborhood (between 6 and n inclusive)}

\item{verbose}{logical. Should status be printed? Deault is FALSE}

\item{justdoit}{logical. Force leapGP to run using specified parameters (may take a long time and/or cause R to crash).}

\item{...}{optional arguments to be passed to laGP()}
}
\value{
a univariate prediction and an updated list of hubs. Also returns scale parameter if scale=TRUE
}
\description{
This function is a modification of the laGP framework of Gramacy and Apley
designed for cases where parallel predictions are not possible (e.g. MCMC).
The leapGP offers a quadratic training algorithm which leads to fast predictions.
}
\examples{
# Generate data
f <- function(x){
   1.3356*(1.5*(1-x[1]) + exp(2*x[1] - 1)*sin(3*pi*(x[1] - 0.6)^2) +
   exp(3*(x[2]-0.5))*sin(4*pi*(x[2] - 0.9)^2))
}
X <- matrix(runif(200), ncol=2)
y <- apply(X, 1, f)

# Generate data for prediction
Xtest <- matrix(runif(200), ncol=2)
ytest <- apply(Xtest, 1, f)

# Train initial model
mod <- leapGP(X, y, M0 = 30)
# Make sequential predictions
pred <- rep(NA, 100)
for(i in 1:100){
  mod <- predict_leapGP(mod, matrix(Xtest[i,], nrow=1), rho=0.9)
  pred[i] <- mod$mean
}
}
