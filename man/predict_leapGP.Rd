% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R
\name{predict_leapGP}
\alias{predict_leapGP}
\title{Predict metthod for leapGP class}
\usage{
predict_leapGP(
  object,
  newdata,
  rho = 0.95,
  scale = FALSE,
  n = ceiling(sqrt(length(y))),
  start = NA,
  M_max = Inf,
  ...
)
}
\arguments{
\item{object}{An object of class `leapGP`}

\item{newdata}{New data}

\item{rho}{parameter controlling time-accuracy tradeoff (default = 0.95)}

\item{scale}{logical. Do we want the scale parameter to be returned for predictions? If TRUE,
the matrix K^{-1} will be stored for each hub.}

\item{n}{local neighborhood size}

\item{start}{number of starting points for neighborhood (between 6 and n inclusive)}

\item{M_max}{the maximum number of hubs allowed (used to upper bound the run time)}

\item{...}{optional arguments to be passed to laGP()}
}
\value{
A list containing values `mean`, `hubs` `X` and `y`. If `scale=TRUE` the list also contains field `sd`.
}
\description{
This function is a modification of the LA-GP framework of Gramacy and Apley
designed for cases where parallel predictions are not possible (i.e. MCMC).
The slapGP framework offers users a time-accuracy tradeoff based on the rho parameter.
}
\examples{
# Generate data
f <- function(x){
   1.3356*(1.5*(1-x[1]) + exp(2*x[1] - 1)*sin(3*pi*(x[1] - 0.6)^2) +
   exp(3*(x[2]-0.5))*sin(4*pi*(x[2] - 0.9)^2))
}
X <- matrix(runif(200), ncol=2)
y <- apply(X, 1, f)

# Generate data for prediction
Xtest <- matrix(runif(200), ncol=2)
ytest <- apply(Xtest, 1, f)

# Train initial model
mod <- leapGP(X, y, M0 = 30)
# Make sequential predictions
pred <- rep(NA, 100)
for(i in 1:100){
  mod <- predict_leapGP(mod, matrix(Xtest[i,], nrow=1), rho=0.9)
  pred[i] <- mod$mean
}
}
